#pragma kernel CSMain

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "../../../Shared/Shaders/Includes/VoxelStructures.hlsl"

// -----------------------------------------------------------------------------
// BUFFERS & UNIFORMS
// -----------------------------------------------------------------------------

// Global Voxel Data
StructuredBuffer<SVONode> _GlobalNodeBuffer;
StructuredBuffer<VoxelPayload> _GlobalPayloadBuffer;
StructuredBuffer<uint> _GlobalBrickDataBuffer;
StructuredBuffer<uint> _PageTableBuffer;
StructuredBuffer<ChunkDef> _ChunkBuffer;
int _ChunkCount;

// TLAS (Top Level Acceleration Structure)
StructuredBuffer<TLASCell> _TLASGridBuffer;
StructuredBuffer<int> _TLASChunkIndexBuffer;
float3 _TLASBoundsMin;
float3 _TLASBoundsMax;
int _TLASResolution;
// Materials & Textures
StructuredBuffer<VoxelTypeGPU> _VoxelMaterialBuffer;
Texture2D<float> _CameraDepthTexture;
Texture2D<float4> _BlueNoiseTexture;
Texture2D<float4> _SourceTex;
Texture2DArray _AlbedoTextureArray;
Texture2DArray _NormalTextureArray;
Texture2DArray _MaskTextureArray;
SamplerState sampler_CameraDepthTexture 
{ 
    Filter = MIN_MAG_MIP_POINT; 
    AddressU = Clamp; 
    AddressV = Clamp; 
};
SamplerState sampler_LinearRepeat 
{ 
    Filter = MIN_MAG_MIP_LINEAR; 
    AddressU = Wrap; 
    AddressV = Wrap; 
};

// Outputs
RWTexture2D<float4> _Result;
RWTexture2D<float> _ResultDepth;
RWStructuredBuffer<float4> _RaycastBuffer;
RWTexture2D<float2> _MotionVectorTexture;

// Matrices & Camera
float4x4 _PrevViewProjMatrix;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4x4 _CameraViewProjection;
float4 _ZBufferParams;
// Lighting & Ray Settings
float4 _MainLightPosition;
float4 _MainLightColor;
float4 _RaytraceParams; // x: LOD scale, yz: jitter
float _DebugNormalDelta;
float _DebugViewNormals;
float _DebugViewBricks;
float4 _MousePosition;
int _MaxIterations;
int _MaxMarchSteps;

#define EPSILON 0.01
#define MAX_BOUNCES 3 

struct HitInfo 
{
    bool hit;
    float3 pos;
    float3 normal;
    uint matId;
    bool isLOD;
    float3 lodColor;
    uint brickId;
};

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS
// -----------------------------------------------------------------------------

float GetInterleavedGradientNoise(float2 pixelPos) 
{
    float3 magic = float3(0.06711056, 0.00583715, 52.9829189);
return frac(magic.z * frac(dot(pixelPos, magic.xy)));
}

float GetDither(uint2 pixelPos) 
{
    uint width, height;
    _BlueNoiseTexture.GetDimensions(width, height);
if (width > 0) 
        return _BlueNoiseTexture[pixelPos % uint2(width, height)].r;
else 
        return GetInterleavedGradientNoise(float2(pixelPos));
}

float2 IntersectBox(float3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax) 
{
    float3 tMin = (boxMin - rayOrigin) / rayDir;
float3 tMax = (boxMax - rayOrigin) / rayDir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return float2(tNear, tFar);
}

float3 GetLODNormal(float3 hitPos, float3 boxPos, float3 boxSize) 
{
    float3 center = boxPos + boxSize * 0.5;
float3 p = hitPos - center;
    float3 signP = sign(p);
    float3 absP = abs(p);
// Bevel logic for LOD boxes
    float bevelSize = boxSize.x * 0.1;
float3 bevelNormal = normalize(max(absP - (boxSize * 0.5 - bevelSize), 0.0) * signP);
    
    if (length(bevelNormal) > 0.001) return bevelNormal;
float maxAxis = max(max(absP.x, absP.y), absP.z);
    if (absP.x >= maxAxis - 1e-4) return float3(signP.x, 0, 0);
if (absP.y >= maxAxis - 1e-4) return float3(0, signP.y, 0);
    return float3(0, 0, signP.z);
}

float3 GetRandomColor(uint seed) 
{
    float3 p3 = frac(float3(seed, seed, seed) * float3(.1031, .1030, .0973));
p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

float3 F_Schlick(float cosTheta, float3 F0)
{
    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);
}

// -----------------------------------------------------------------------------
// VOXEL SAMPLING
// -----------------------------------------------------------------------------

float SampleBrick(uint brickOffset, uint brickPtr, float3 localPos) 
{
    float3 p = localPos + (float)BRICK_PADDING;
int3 i = clamp((int3)floor(p), 0, BRICK_STORAGE_SIZE - 2);
    float3 f = p - (float3)i;
uint baseIdx = brickOffset + brickPtr + (i.z * BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE) + (i.y * BRICK_STORAGE_SIZE) + i.x;
uint sliceStride = BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE;
    
    float s000, s001, s010, s011, s100, s101, s110, s111;
    float3 n;
    uint m;
UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx], s000, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + 1], s001, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + BRICK_STORAGE_SIZE], s010, n, m);
UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + BRICK_STORAGE_SIZE + 1], s011, n, m);
    
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride], s100, n, m);
UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + 1], s101, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + BRICK_STORAGE_SIZE], s110, n, m);
UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + BRICK_STORAGE_SIZE + 1], s111, n, m);
float res = lerp(
        lerp(lerp(s000, s001, f.x), lerp(s010, s011, f.x), f.y),
        lerp(lerp(s100, s101, f.x), lerp(s110, s111, f.x), f.y),
        f.z
    );
return res;
}

float3 GetVoxelNormal(uint brickOffset, uint brickPtr, float3 localPos) 
{
    float3 p = localPos + (float)BRICK_PADDING;
int3 i = clamp((int3)floor(p), 0, BRICK_STORAGE_SIZE - 2);
    float3 f = p - (float3)i;
uint baseIdx = brickOffset + brickPtr + (i.z * BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE) + (i.y * BRICK_STORAGE_SIZE) + i.x;
uint sliceStride = BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE;
    
    float s;
    float3 v000, v001, v010, v011, v100, v101, v110, v111;
    uint m;
UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx], s, v000, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + 1], s, v001, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + BRICK_STORAGE_SIZE], s, v010, m);
UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + BRICK_STORAGE_SIZE + 1], s, v011, m);
    
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride], s, v100, m);
UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + 1], s, v101, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + BRICK_STORAGE_SIZE], s, v110, m);
UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + BRICK_STORAGE_SIZE + 1], s, v111, m);
    
    float3 mixX00 = lerp(v000, v001, f.x);
float3 mixX01 = lerp(v010, v011, f.x);
    float3 mixX10 = lerp(v100, v101, f.x);
    float3 mixX11 = lerp(v110, v111, f.x);
float3 mixY0 = lerp(mixX00, mixX01, f.y);
    float3 mixY1 = lerp(mixX10, mixX11, f.y);
    
    return normalize(lerp(mixY0, mixY1, f.z));
}

uint GetVoxelMaterial(uint brickOffset, uint brickPtr, float3 localPos) 
{
    float3 p = localPos + (float)BRICK_PADDING;
uint3 i = clamp((uint3)floor(p + 0.5), 0, BRICK_STORAGE_SIZE - 1);
uint idx = brickOffset + brickPtr + i.z * BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE + i.y * BRICK_STORAGE_SIZE + i.x;
    
    float s;
float3 n;
    uint mat;
    UnpackVoxelData(_GlobalBrickDataBuffer[idx], s, n, mat);
    return mat;
}

// -----------------------------------------------------------------------------
// LIGHTING & MATERIALS
// -----------------------------------------------------------------------------

float3 LightingWhitted(float3 albedo, float3 N, float3 V, float3 L, float3 lightColor, float roughness, float metallic, float ao, float shadowAtten)
{
    // 1. Diffuse (Lambetian with Toon ramp option)
    float NdotL = dot(N, L);
    // Smoothstep for stylized look, or just saturate(NdotL) for standard
    float lightIntensity = smoothstep(0.0, 0.05, NdotL) * shadowAtten;

    // 2. Specular (Hard Highlights)
    float3 H = normalize(L + V);
    float NdotH = max(dot(N, H), 0.0);
    
    float specThreshold = 1.0 - (roughness * 0.1);
    float specIntensity = smoothstep(specThreshold, specThreshold + 0.01, NdotH) * shadowAtten;
    
    // 3. Rim Light (Outline Highlight)
    // Rim should only appear if lit or if it's an emissive-like effect. 
    // Usually rim requires some ambient or backlight.
    float NdotV = dot(N, V);
    float rim = 1.0 - NdotV;
    float rimThreshold = 0.6;
    float rimIntensity = smoothstep(rimThreshold, rimThreshold + 0.05, rim) * lightIntensity;
    
    // 4. Ambient / Shadow Color
    float3 ambientColor = float3(0.1, 0.15, 0.25) * albedo * ao;
    float3 litColor = albedo * lightColor;

    // Combine
    float3 finalColor = lerp(ambientColor, litColor, lightIntensity);
    
    // Add Specular and Rim (dielectrics have white spec, metals have albedo spec)
    float3 specColor = lerp(lightColor, albedo * lightColor, metallic);
    finalColor += specIntensity * specColor * 0.8;
    finalColor += rimIntensity * lightColor * 0.5;

    return finalColor;
}

void TriplanarSampling(float3 worldPos, float3 normal, uint matId, out float3 outAlbedo, out float3 outNormal, out float outRoughness, out float outMetallic, out float outAO, float lod) 
{
    if (matId == 0) 
    {
        outAlbedo = 1;
outNormal = normal; outRoughness = 0.5; outMetallic = 0; outAO = 1;
        return;
}
    
    VoxelTypeGPU mat = _VoxelMaterialBuffer[matId];
// Calculate weights
    float3 weights = abs(normal);
    weights = pow(weights, 8.0);
float weightSum = weights.x + weights.y + weights.z;
    weights /= (weightSum + 1e-5);
    
    float3 accumAlbedo = 0;
float accumAO = 0;
    float accumRoughness = 0;
    float accumMetallic = 0;
// X Projection
    if (weights.x > 0.01) 
    {
        float2 uv = worldPos.zy;
float3 col = _AlbedoTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, mat.sideAlbedoIndex), lod).rgb;
        float4 mask = _MaskTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, mat.sideMaskIndex), lod);
        accumAlbedo += col * weights.x;
accumAO += mask.g * weights.x;
        accumRoughness += mask.b * weights.x;
        accumMetallic += mat.sideMetallic * weights.x;
}
    
    // Y Projection
    if (weights.y > 0.01) 
    {
        float2 uv = worldPos.xz;
uint albedoID = (normal.y > 0) ? mat.topAlbedoIndex : mat.sideAlbedoIndex;
        uint maskID = (normal.y > 0) ? mat.topMaskIndex : mat.sideMaskIndex;
float met = (normal.y > 0) ? mat.topMetallic : mat.sideMetallic;
        
        float3 col = _AlbedoTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, albedoID), lod).rgb;
float4 mask = _MaskTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, maskID), lod);
        accumAlbedo += col * weights.y;
        accumAO += mask.g * weights.y;
accumRoughness += mask.b * weights.y;
        accumMetallic += met * weights.y;
}
    
    // Z Projection
    if (weights.z > 0.01) 
    {
        float2 uv = worldPos.xy;
float3 col = _AlbedoTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, mat.sideAlbedoIndex), lod).rgb;
        float4 mask = _MaskTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, mat.sideMaskIndex), lod);
        accumAlbedo += col * weights.z;
accumAO += mask.g * weights.z;
        accumRoughness += mask.b * weights.z;
        accumMetallic += mat.sideMetallic * weights.z;
}
    
    outAlbedo = accumAlbedo;
    outAO = accumAO;
    outRoughness = accumRoughness;
    outMetallic = accumMetallic;
outNormal = normal;
}

// -----------------------------------------------------------------------------
// TRAVERSAL
// -----------------------------------------------------------------------------

HitInfo TraceSVO(ChunkDef chunk, float3 rayOriginNode, float3 rayDir, float maxDist, float tStart)
{
    float tCurrent = tStart;
float tEnd = maxDist;
    int iter = 0;
    float gridSz = 64.0;
    
    HitInfo result;
    result.hit = false;
    result.pos = 0;
result.normal = 0;
    result.matId = 0;
    result.isLOD = false;
    result.lodColor = 0;
    result.brickId = 0;
while (tCurrent < tEnd && iter < _MaxIterations) 
    {
        iter++;
float3 pos = rayOriginNode + rayDir * (tCurrent + EPSILON);
        uint nodeIndex = 0;
        float nodeSize = gridSz;
float3 nodePos = float3(0,0,0);
        bool hitLeaf = false;
        
        // Traverse Octree Layers
        for (int depth = 0; depth < 5; depth++) 
        {
            float halfSize = nodeSize * 0.5;
float3 center = nodePos + halfSize;
            int octant = 0;
            if (pos.x >= center.x) octant |= 1;
if (pos.y >= center.y) octant |= 2;
            if (pos.z >= center.z) octant |= 4;
            
            SVONode node = _GlobalNodeBuffer[GetPhysicalIndex(nodeIndex, chunk.pageTableOffset, _PageTableBuffer)];
uint childMask = (node.topology >> 24) & 0xFF;
            
            if ((childMask & (1 << octant)) != 0) 
            {
                uint childBase = node.topology & 0xFFFFFF;
uint maskBefore = childMask & ((1 << octant) - 1);
                uint childNodeIndex = childBase + countbits(maskBefore);
float3 childPos = nodePos + float3((octant & 1) ? halfSize : 0, (octant & 2) ? halfSize : 0, (octant & 4) ? halfSize : 0);
float3 childSize = halfSize;
                
                nodeIndex = childNodeIndex;
                nodeSize = childSize;
                nodePos = childPos;
if (nodeSize <= BRICK_SIZE + EPSILON) 
                {
                    hitLeaf = true;
break;
                }
            }
            else 
            {
                // Missed child, skip to next octant boundary
                float3 octantMin = nodePos + float3((octant & 1) ? halfSize : 0, (octant & 2) ? halfSize : 0, (octant & 4) ? 
halfSize : 0);
                float2 tOctant = IntersectBox(rayOriginNode, rayDir, octantMin, octantMin + halfSize);
                tCurrent = tOctant.y;
                break;
}
        }
        
        if (hitLeaf) 
        {
            SVONode leafNode = _GlobalNodeBuffer[GetPhysicalIndex(nodeIndex, chunk.pageTableOffset, _PageTableBuffer)];
float2 tLeaf = IntersectBox(rayOriginNode, rayDir, nodePos, nodePos + nodeSize);
            
            // Check for LOD/Solid leaf
            if (leafNode.packedInfo & NODE_FLAG_SOLID) 
            {
                result.hit = true;
result.pos = rayOriginNode + rayDir * tLeaf.x;
                result.normal = GetLODNormal(result.pos, nodePos, float3(nodeSize, nodeSize, nodeSize));
result.matId = (leafNode.packedInfo >> 16) & 0xFF;
                result.brickId = 0;
                result.isLOD = true;
                result.lodColor = UnpackColor(leafNode.lodColor).rgb; 
                return result;
}
            
            // Handle Voxel Payload
            uint payloadIndex, matID;
UnpackNode(leafNode, payloadIndex, matID);
            
            if (payloadIndex != 0) 
            {
                VoxelPayload payload = _GlobalPayloadBuffer[GetPhysicalIndex(payloadIndex, chunk.payloadPageTableOffset, _PageTableBuffer)];
uint brickPtr = payload.brickDataIndex;
                float tMarch = max(tCurrent, tLeaf.x);
                float marchEnd = min(tEnd, tLeaf.y);
// Raymarch inside brick
                for (int m = 0; m < _MaxMarchSteps; m++) 
                {
                    if (tMarch >= marchEnd) break;
float3 p = rayOriginNode + rayDir * tMarch;
                    float3 localPos = p - nodePos;
                    float dist = SampleBrick(chunk.brickOffset, brickPtr, localPos);
if (dist < EPSILON) 
                    {
                        // Binary search refinement for exact surface hit
                        float tMin = tMarch - 0.05;
float tMax = tMarch;
                        for(int r = 0; r < 4; r++) 
                        {
                            float tMid = (tMin + tMax) * 0.5;
float dMid = SampleBrick(chunk.brickOffset, brickPtr, (rayOriginNode + rayDir * tMid) - nodePos);
                            if (dMid < EPSILON) tMax = tMid;
else tMin = tMid;
                        }
                        tMarch = tMax;
p = rayOriginNode + rayDir * tMarch;
                        localPos = p - nodePos;
                        
                        result.hit = true;
                        result.pos = p;
result.normal = GetVoxelNormal(chunk.brickOffset, brickPtr, localPos);
                        result.matId = GetVoxelMaterial(chunk.brickOffset, brickPtr, localPos);
                        result.brickId = brickPtr;
                        return result;
}
                    tMarch += max(dist, 0.001);
}
            }
            tCurrent = tLeaf.y + EPSILON;
}
    }
    return result;
}

// --- New: Trace Full Scene (TLAS + SVO) ---
HitInfo TraceScene(float3 rayOrigin, float3 rayDir, float maxDist)
{
    HitInfo bestHit = (HitInfo)0;
    bestHit.hit = false;
    float closestT = maxDist;

    // TLAS Traversal (Grid DDA)
    float2 tScene = IntersectBox(rayOrigin, rayDir, _TLASBoundsMin, _TLASBoundsMax);
    if (tScene.x < tScene.y && tScene.y > 0) 
    {
        float tCurrent = max(0.0, tScene.x);
        float tMaxLimit = min(closestT, tScene.y);
        float3 cellSize = (_TLASBoundsMax - _TLASBoundsMin) / float(_TLASResolution);
        float3 invDir = 1.0 / (rayDir + sign(rayDir) * 1e-6);
        float3 startPos = rayOrigin + rayDir * (tCurrent + 1e-4) - _TLASBoundsMin;
        int3 cellIdx = clamp(int3(startPos / cellSize), 0, _TLASResolution - 1);
        int3 step = int3(sign(rayDir));
        float3 tDelta = abs(cellSize * invDir);
        float3 cellBoundMin = _TLASBoundsMin + float3(cellIdx) * cellSize;
        float3 cellBoundMax = cellBoundMin + cellSize;
        float3 nextBoundary = float3(
            rayDir.x > 0 ? cellBoundMax.x : cellBoundMin.x,
            rayDir.y > 0 ? cellBoundMax.y : cellBoundMin.y,
            rayDir.z > 0 ? cellBoundMax.z : cellBoundMin.z
        );
        float3 tNext = (nextBoundary - rayOrigin) * invDir;

        int iter = 0;
        int maxIter = _TLASResolution * 3;
        while (iter < maxIter && tCurrent < tMaxLimit) 
        {
             if (all(cellIdx >= 0) && all(cellIdx < _TLASResolution)) 
             {
                 uint flatIdx = cellIdx.z * _TLASResolution * _TLASResolution + cellIdx.y * _TLASResolution + cellIdx.x;
                 TLASCell cell = _TLASGridBuffer[flatIdx];
                 
                 for (uint k = 0; k < cell.count; k++) 
                 {
                     int chunkId = _TLASChunkIndexBuffer[cell.offset + k];
                     ChunkDef chunk = _ChunkBuffer[chunkId];
                     float2 tBox = IntersectBox(rayOrigin, rayDir, chunk.boundsMin, chunk.boundsMax);
                     if (tBox.x < tBox.y && tBox.x < closestT && tBox.y > tCurrent - 0.01) 
                     {
                         if (tBox.y > tCurrent) 
                         {
                              float3 localOrigin = mul(chunk.worldToLocal, float4(rayOrigin, 1.0)).xyz;
                              float3 localDir = normalize(mul((float3x3)chunk.worldToLocal, rayDir));
                              float boundsSz = 64.0;
                              float2 tLocalBox = IntersectBox(localOrigin, localDir, float3(0,0,0), float3(boundsSz, boundsSz, boundsSz));
                              if (tLocalBox.x < tLocalBox.y && tLocalBox.y > 0) 
                              {
                                 float tStartL = max(0.0, tLocalBox.x);
                                 float tEndL = tLocalBox.y;
                                 HitInfo info = TraceSVO(chunk, localOrigin, localDir, tEndL, tStartL);
                                 if (info.hit) 
                                 {
                                     float3 hitWorld = mul(chunk.localToWorld, float4(info.pos, 1.0)).xyz;
                                     float dist = length(hitWorld - rayOrigin);
                                     if (dist < closestT) 
                                     {
                                         closestT = dist;
                                         bestHit = info;
                                         bestHit.pos = hitWorld;
                                         bestHit.normal = normalize(mul(info.normal, (float3x3)chunk.worldToLocal));
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
             
             // Step DDA
             float tExit = min(min(tNext.x, tNext.y), tNext.z);
             if (closestT < tExit) break;
             
             tCurrent = tExit;
             if (tNext.x <= tNext.y && tNext.x <= tNext.z) 
             {
                 tNext.x += tDelta.x;
                 cellIdx.x += step.x;
             } 
             else if (tNext.y <= tNext.z) 
             {
                 tNext.y += tDelta.y;
                 cellIdx.y += step.y;
             } 
             else 
             {
                 tNext.z += tDelta.z;
                 cellIdx.z += step.z;
             }
             iter++;
        }
    }
    return bestHit;
}

// --- New: Trace Shadow (Optimized for Boolean Hit) ---
bool TraceShadow(float3 rayOrigin, float3 rayDir, float maxDist)
{
    float2 tScene = IntersectBox(rayOrigin, rayDir, _TLASBoundsMin, _TLASBoundsMax);
    if (tScene.x < tScene.y && tScene.y > 0) 
    {
        float tCurrent = max(0.0, tScene.x);
        float tMaxLimit = min(maxDist, tScene.y);
        float3 cellSize = (_TLASBoundsMax - _TLASBoundsMin) / float(_TLASResolution);
        float3 invDir = 1.0 / (rayDir + sign(rayDir) * 1e-6);
        float3 startPos = rayOrigin + rayDir * (tCurrent + 1e-4) - _TLASBoundsMin;
        int3 cellIdx = clamp(int3(startPos / cellSize), 0, _TLASResolution - 1);
        int3 step = int3(sign(rayDir));
        float3 tDelta = abs(cellSize * invDir);
        float3 cellBoundMin = _TLASBoundsMin + float3(cellIdx) * cellSize;
        float3 cellBoundMax = cellBoundMin + cellSize;
        float3 nextBoundary = float3(
            rayDir.x > 0 ? cellBoundMax.x : cellBoundMin.x,
            rayDir.y > 0 ? cellBoundMax.y : cellBoundMin.y,
            rayDir.z > 0 ? cellBoundMax.z : cellBoundMin.z
        );
        float3 tNext = (nextBoundary - rayOrigin) * invDir;

        int iter = 0;
        int maxIter = _TLASResolution * 2; // Can use fewer iterations for shadow
        while (iter < maxIter && tCurrent < tMaxLimit) 
        {
             if (all(cellIdx >= 0) && all(cellIdx < _TLASResolution)) 
             {
                 uint flatIdx = cellIdx.z * _TLASResolution * _TLASResolution + cellIdx.y * _TLASResolution + cellIdx.x;
                 TLASCell cell = _TLASGridBuffer[flatIdx];
                 
                 for (uint k = 0; k < cell.count; k++) 
                 {
                     int chunkId = _TLASChunkIndexBuffer[cell.offset + k];
                     ChunkDef chunk = _ChunkBuffer[chunkId];
                     float2 tBox = IntersectBox(rayOrigin, rayDir, chunk.boundsMin, chunk.boundsMax);
                     // Shadow Ray can exit early on any hit
                     if (tBox.x < tBox.y && tBox.x < maxDist && tBox.y > tCurrent) 
                     {
                          float3 localOrigin = mul(chunk.worldToLocal, float4(rayOrigin, 1.0)).xyz;
                          float3 localDir = normalize(mul((float3x3)chunk.worldToLocal, rayDir));
                          float boundsSz = 64.0;
                          float2 tLocalBox = IntersectBox(localOrigin, localDir, float3(0,0,0), float3(boundsSz, boundsSz, boundsSz));
                          if (tLocalBox.x < tLocalBox.y && tLocalBox.y > 0) 
                          {
                             float tStartL = max(0.0, tLocalBox.x);
                             float tEndL = tLocalBox.y;
                             HitInfo info = TraceSVO(chunk, localOrigin, localDir, tEndL, tStartL);
                             if (info.hit) return true; // SHADOW HIT
                         }
                     }
                 }
             }
             
             float tExit = min(min(tNext.x, tNext.y), tNext.z);
             tCurrent = tExit;
             if (tNext.x <= tNext.y && tNext.x <= tNext.z) 
             {
                 tNext.x += tDelta.x;
                 cellIdx.x += step.x;
             } 
             else if (tNext.y <= tNext.z) 
             {
                 tNext.y += tDelta.y;
                 cellIdx.y += step.y;
             } 
             else 
             {
                 tNext.z += tDelta.z;
                 cellIdx.z += step.z;
             }
             iter++;
        }
    }
    return false;
}

// -----------------------------------------------------------------------------
// KERNEL
// -----------------------------------------------------------------------------

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    _Result.GetDimensions(width, height);
if (id.x >= width || id.y >= height) return;

    // 1. Ray Generation
    float2 jitter = _RaytraceParams.yz;
float2 uv = (id.xy + 0.5 + jitter) / float2(width, height) * 2.0 - 1.0;
float4 viewRay = mul(_CameraInverseProjection, float4(uv, 0.0, 1.0));
    float3 rayDir = normalize(mul((float3x3)_CameraToWorld, viewRay.xyz));
    float3 rayOrigin = _CameraToWorld._m03_m13_m23;
// Depth Buffer Culling
    float depthVal = _CameraDepthTexture.SampleLevel(sampler_CameraDepthTexture, (id.xy + 0.5) / float2(width, height), 0);
float linearDepth = 1.0 / (_ZBufferParams.z * depthVal + _ZBufferParams.w);
    float3 forward = normalize(mul((float3x3)_CameraToWorld, float3(0, 0, 1)));
float maxDist = linearDepth / max(dot(rayDir, forward), 0.0001);
    
    float dither = GetDither(id.xy);
    rayOrigin += rayDir * dither * 0.05;

    // --- WHITTED RAY TRACING LOOP ---
    
    float3 currentRayOrigin = rayOrigin;
    float3 currentRayDir = rayDir;
    float currentMaxDist = maxDist;
    float3 throughput = 1.0;
    float3 accumColor = 0.0;
    
    // Save info for primary hit (motion vectors, depth)
    bool primaryHit = false;
    float3 primaryPos = 0;

    for(int bounce = 0; bounce <= MAX_BOUNCES; bounce++)
    {
        HitInfo hit = TraceScene(currentRayOrigin, currentRayDir, currentMaxDist);
        
        if (hit.hit)
        {
            if (bounce == 0)
            {
                primaryHit = true;
                primaryPos = hit.pos;
                // Debug Views handled below
            }

            // Material Decoding
            float3 albedo, normal;
            float roughness, ao, metallic;
            if (hit.isLOD) 
            {
                float dist = length(hit.pos - currentRayOrigin);
                float spotSize = dist * _RaytraceParams.x;
                float mip = max(0.0, log2(spotSize * 16.0));
                TriplanarSampling(hit.pos, hit.normal, hit.matId, albedo, normal, roughness, metallic, ao, mip);
            } 
            else 
            {
                TriplanarSampling(hit.pos, hit.normal, hit.matId, albedo, normal, roughness, metallic, ao, 0);
            }
            
            // Lighting
            float3 V = -currentRayDir;
            float3 L = normalize(_MainLightPosition.xyz);
            
            // Shadow Ray
            // Offset slightly along normal to prevent self-shadowing
            bool inShadow = TraceShadow(hit.pos + normal * 0.05, L, 1000.0);
            float shadowAtten = inShadow ? 0.0 : 1.0;

            float3 directLight = LightingWhitted(albedo, normal, V, L, _MainLightColor.rgb, roughness, metallic, ao, shadowAtten);
            
            accumColor += directLight * throughput;

            // Debug Overrides (Only for primary bounce)
            if (bounce == 0)
            {
                if (_DebugViewBricks > 0.5) {
                    if (hit.isLOD) accumColor = float3(1.0, 0.0, 0.0) * 0.5 + hit.lodColor * 0.5;
                    else if (hit.brickId == 0) accumColor = float3(0, 1, 0);
                    else accumColor = GetRandomColor(hit.brickId);
                    throughput = 0; // Stop bounces
                }
                if (_DebugViewNormals > 0.5) {
                    accumColor = normal * 0.5 + 0.5;
                    throughput = 0; // Stop bounces
                }
            }

            // Prepare Recursive Ray (Reflection)
            // Whitted assumes everything reflects to some degree based on Fresnel
            float3 F0 = lerp(0.04, albedo, metallic);
            float3 F = F_Schlick(max(dot(normal, V), 0.0), F0);
            
            // Throughput scaling
            throughput *= F;
            
            // Update Ray
            currentRayDir = reflect(currentRayDir, normal);
            currentRayOrigin = hit.pos + normal * 0.01;
            currentMaxDist = 1000.0; // Infinite for reflection

            // Terminate if signal is too weak
            if (max(throughput.x, max(throughput.y, throughput.z)) < 0.01) break;
        }
        else
        {
            // Miss Shader / Skybox
            if (bounce == 0)
            {
                float2 sampleUV = uv * 0.5 + 0.5;
                float4 skyColor = _SourceTex.SampleLevel(sampler_LinearRepeat, sampleUV, 0);
                accumColor += skyColor.rgb * throughput;
                
                // Depth/Motion for Sky
                _ResultDepth[id.xy] = 0.0;
                float3 farPos = rayOrigin + rayDir * 1000.0;
                float4 clipPos = mul(_CameraViewProjection, float4(farPos, 1.0));
                float4 prevClipPos = mul(_PrevViewProjMatrix, float4(farPos, 1.0));
                float2 ndc = clipPos.xy / clipPos.w;
                float2 prevNdc = prevClipPos.xy / prevClipPos.w;
                _MotionVectorTexture[id.xy] = (ndc * 0.5 + 0.5) - (prevNdc * 0.5 + 0.5);
            }
            else
            {
                // Reflection Miss (Simple Ambient fallback as we don't have a cubemap bound)
                float3 ambientMiss = float3(0.1, 0.15, 0.25); 
                accumColor += ambientMiss * throughput;
            }
            break;
        }
    }

    // Output Color
    _Result[id.xy] = float4(accumColor, 1.0);
    
    // Output Depth & Motion (Primary Hit Only)
    if (primaryHit)
    {
        float4 clipPos = mul(_CameraViewProjection, float4(primaryPos, 1.0));
        _ResultDepth[id.xy] = clipPos.z / clipPos.w;
        
        float4 prevClipPos = mul(_PrevViewProjMatrix, float4(primaryPos, 1.0));
        float2 ndc = clipPos.xy / clipPos.w;
        float2 prevNdc = prevClipPos.xy / prevClipPos.w;
        _MotionVectorTexture[id.xy] = (ndc * 0.5 + 0.5) - (prevNdc * 0.5 + 0.5);
        
        // Mouse Picking
        if (all(id.xy == (uint2)_MousePosition)) 
        {
            _RaycastBuffer[0] = float4(primaryPos, 1.0);
        }
    }
}