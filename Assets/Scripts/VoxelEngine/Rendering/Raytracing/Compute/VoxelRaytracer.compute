#pragma kernel CSMain

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "../../../Shared/Shaders/Includes/VoxelStructures.hlsl"

// -----------------------------------------------------------------------------
// BUFFERS & UNIFORMS
// -----------------------------------------------------------------------------

// Global Voxel Data
StructuredBuffer<SVONode> _GlobalNodeBuffer;
StructuredBuffer<VoxelPayload> _GlobalPayloadBuffer;
StructuredBuffer<uint> _GlobalBrickDataBuffer;
StructuredBuffer<uint> _PageTableBuffer;
StructuredBuffer<ChunkDef> _ChunkBuffer;
int _ChunkCount;

// TLAS (Top Level Acceleration Structure)
StructuredBuffer<TLASCell> _TLASGridBuffer;
StructuredBuffer<int> _TLASChunkIndexBuffer;
float3 _TLASBoundsMin;
float3 _TLASBoundsMax;
int _TLASResolution;

// Materials & Textures
StructuredBuffer<VoxelTypeGPU> _VoxelMaterialBuffer;
Texture2D<float> _CameraDepthTexture;
Texture2D<float4> _BlueNoiseTexture;
Texture2D<float4> _SourceTex;
Texture2DArray _AlbedoTextureArray;
Texture2DArray _NormalTextureArray;
Texture2DArray _MaskTextureArray;

SamplerState sampler_CameraDepthTexture 
{ 
    Filter = MIN_MAG_MIP_POINT; 
    AddressU = Clamp; 
    AddressV = Clamp; 
};

SamplerState sampler_LinearRepeat 
{ 
    Filter = MIN_MAG_MIP_LINEAR; 
    AddressU = Wrap; 
    AddressV = Wrap; 
};

// Outputs
RWTexture2D<float4> _Result;
RWTexture2D<float> _ResultDepth;
RWStructuredBuffer<float4> _RaycastBuffer;
RWTexture2D<float2> _MotionVectorTexture;

// Matrices & Camera
float4x4 _PrevViewProjMatrix;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4x4 _CameraViewProjection;
float4 _ZBufferParams;

// Lighting & Ray Settings
float4 _MainLightPosition;
float4 _MainLightColor;
float4 _RaytraceParams; // x: LOD scale, yz: jitter
float _DebugNormalDelta;
float _DebugViewNormals;
float _DebugViewBricks;
float4 _MousePosition;
int _MaxIterations;
int _MaxMarchSteps;

#define EPSILON 0.01

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS
// -----------------------------------------------------------------------------

float GetInterleavedGradientNoise(float2 pixelPos) 
{
    float3 magic = float3(0.06711056, 0.00583715, 52.9829189);
    return frac(magic.z * frac(dot(pixelPos, magic.xy)));
}

float GetDither(uint2 pixelPos) 
{
    uint width, height;
    _BlueNoiseTexture.GetDimensions(width, height);
    if (width > 0) 
        return _BlueNoiseTexture[pixelPos % uint2(width, height)].r;
    else 
        return GetInterleavedGradientNoise(float2(pixelPos));
}

float2 IntersectBox(float3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax) 
{
    float3 tMin = (boxMin - rayOrigin) / rayDir;
    float3 tMax = (boxMax - rayOrigin) / rayDir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return float2(tNear, tFar);
}

float3 GetLODNormal(float3 hitPos, float3 boxPos, float3 boxSize) 
{
    float3 center = boxPos + boxSize * 0.5;
    float3 p = hitPos - center;
    float3 signP = sign(p);
    float3 absP = abs(p);
    
    // Bevel logic for LOD boxes
    float bevelSize = boxSize.x * 0.1;
    float3 bevelNormal = normalize(max(absP - (boxSize * 0.5 - bevelSize), 0.0) * signP);
    
    if (length(bevelNormal) > 0.001) return bevelNormal;
    
    float maxAxis = max(max(absP.x, absP.y), absP.z);
    if (absP.x >= maxAxis - 1e-4) return float3(signP.x, 0, 0);
    if (absP.y >= maxAxis - 1e-4) return float3(0, signP.y, 0);
    return float3(0, 0, signP.z);
}

float3 GetRandomColor(uint seed) 
{
    float3 p3 = frac(float3(seed, seed, seed) * float3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

// -----------------------------------------------------------------------------
// VOXEL SAMPLING
// -----------------------------------------------------------------------------

float SampleBrick(uint brickOffset, uint brickPtr, float3 localPos) 
{
    float3 p = localPos + (float)BRICK_PADDING;
    int3 i = clamp((int3)floor(p), 0, BRICK_STORAGE_SIZE - 2);
    float3 f = p - (float3)i;
    
    uint baseIdx = brickOffset + brickPtr + (i.z * BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE) + (i.y * BRICK_STORAGE_SIZE) + i.x;
    uint sliceStride = BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE;
    
    float s000, s001, s010, s011, s100, s101, s110, s111;
    float3 n;
    uint m;
    
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx], s000, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + 1], s001, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + BRICK_STORAGE_SIZE], s010, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + BRICK_STORAGE_SIZE + 1], s011, n, m);
    
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride], s100, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + 1], s101, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + BRICK_STORAGE_SIZE], s110, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + BRICK_STORAGE_SIZE + 1], s111, n, m);
    
    float res = lerp(
        lerp(lerp(s000, s001, f.x), lerp(s010, s011, f.x), f.y),
        lerp(lerp(s100, s101, f.x), lerp(s110, s111, f.x), f.y),
        f.z
    );
    return res;
}

float3 GetVoxelNormal(uint brickOffset, uint brickPtr, float3 localPos) 
{
    float3 p = localPos + (float)BRICK_PADDING;
    int3 i = clamp((int3)floor(p), 0, BRICK_STORAGE_SIZE - 2);
    float3 f = p - (float3)i;
    
    uint baseIdx = brickOffset + brickPtr + (i.z * BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE) + (i.y * BRICK_STORAGE_SIZE) + i.x;
    uint sliceStride = BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE;
    
    float s;
    float3 v000, v001, v010, v011, v100, v101, v110, v111;
    uint m;
    
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx], s, v000, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + 1], s, v001, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + BRICK_STORAGE_SIZE], s, v010, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + BRICK_STORAGE_SIZE + 1], s, v011, m);
    
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride], s, v100, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + 1], s, v101, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + BRICK_STORAGE_SIZE], s, v110, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + BRICK_STORAGE_SIZE + 1], s, v111, m);
    
    float3 mixX00 = lerp(v000, v001, f.x);
    float3 mixX01 = lerp(v010, v011, f.x);
    float3 mixX10 = lerp(v100, v101, f.x);
    float3 mixX11 = lerp(v110, v111, f.x);
    
    float3 mixY0 = lerp(mixX00, mixX01, f.y);
    float3 mixY1 = lerp(mixX10, mixX11, f.y);
    
    return normalize(lerp(mixY0, mixY1, f.z));
}

uint GetVoxelMaterial(uint brickOffset, uint brickPtr, float3 localPos) 
{
    float3 p = localPos + (float)BRICK_PADDING;
    uint3 i = clamp((uint3)floor(p + 0.5), 0, BRICK_STORAGE_SIZE - 1);
    uint idx = brickOffset + brickPtr + i.z * BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE + i.y * BRICK_STORAGE_SIZE + i.x;
    
    float s;
    float3 n;
    uint mat;
    UnpackVoxelData(_GlobalBrickDataBuffer[idx], s, n, mat);
    return mat;
}

// -----------------------------------------------------------------------------
// LIGHTING & MATERIALS
// -----------------------------------------------------------------------------

float3 LightingCel(float3 albedo, float3 N, float3 V, float3 L, float3 lightColor, float roughness, float metallic, float ao)
{
    // 1. Diffuse Banding (The "Toon" ramp)
    float NdotL = dot(N, L);
    float lightIntensity = smoothstep(0.0, 0.05, NdotL);

    // 2. Specular (Hard Highlights)
    float3 H = normalize(L + V);
    float NdotH = max(dot(N, H), 0.0);
    
    // Calculate Stylized Specular size based on roughness
    float specThreshold = 1.0 - (roughness * 0.1); 
    float specIntensity = smoothstep(specThreshold, specThreshold + 0.01, NdotH);
    
    // 3. Rim Light (Outline Highlight)
    float NdotV = dot(N, V);
    float rim = 1.0 - NdotV;
    float rimThreshold = 0.6;
    float rimIntensity = smoothstep(rimThreshold, rimThreshold + 0.05, rim) * lightIntensity;
    
    // 4. Ambient / Shadow Color
    float3 ambientColor = float3(0.1, 0.15, 0.25) * albedo; 
    float3 litColor = albedo * lightColor;

    // Combine
    float3 finalColor = lerp(ambientColor, litColor, lightIntensity);
    
    // Add Specular and Rim
    finalColor += specIntensity * lightColor * 0.8 * (1.0 - metallic);
    finalColor += rimIntensity * lightColor * 0.5;

    return finalColor * ao;
}

void TriplanarSampling(float3 worldPos, float3 normal, uint matId, out float3 outAlbedo, out float3 outNormal, out float outRoughness, out float outMetallic, out float outAO, float lod) 
{
    if (matId == 0) 
    {
        outAlbedo = 1; outNormal = normal; outRoughness = 0.5; outMetallic = 0; outAO = 1;
        return;
    }
    
    VoxelTypeGPU mat = _VoxelMaterialBuffer[matId];
    
    // Calculate weights
    float3 weights = abs(normal);
    weights = pow(weights, 8.0);
    float weightSum = weights.x + weights.y + weights.z;
    weights /= (weightSum + 1e-5);
    
    float3 accumAlbedo = 0;
    float accumAO = 0;
    float accumRoughness = 0;
    float accumMetallic = 0;
    
    // X Projection
    if (weights.x > 0.01) 
    {
        float2 uv = worldPos.zy;
        float3 col = _AlbedoTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, mat.sideAlbedoIndex), lod).rgb;
        float4 mask = _MaskTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, mat.sideMaskIndex), lod);
        accumAlbedo += col * weights.x;
        accumAO += mask.g * weights.x;
        accumRoughness += mask.b * weights.x;
        accumMetallic += mat.sideMetallic * weights.x;
    }
    
    // Y Projection
    if (weights.y > 0.01) 
    {
        float2 uv = worldPos.xz;
        uint albedoID = (normal.y > 0) ? mat.topAlbedoIndex : mat.sideAlbedoIndex;
        uint maskID = (normal.y > 0) ? mat.topMaskIndex : mat.sideMaskIndex;
        float met = (normal.y > 0) ? mat.topMetallic : mat.sideMetallic;
        
        float3 col = _AlbedoTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, albedoID), lod).rgb;
        float4 mask = _MaskTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, maskID), lod);
        accumAlbedo += col * weights.y;
        accumAO += mask.g * weights.y;
        accumRoughness += mask.b * weights.y;
        accumMetallic += met * weights.y;
    }
    
    // Z Projection
    if (weights.z > 0.01) 
    {
        float2 uv = worldPos.xy;
        float3 col = _AlbedoTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, mat.sideAlbedoIndex), lod).rgb;
        float4 mask = _MaskTextureArray.SampleLevel(sampler_LinearRepeat, float3(uv, mat.sideMaskIndex), lod);
        accumAlbedo += col * weights.z;
        accumAO += mask.g * weights.z;
        accumRoughness += mask.b * weights.z;
        accumMetallic += mat.sideMetallic * weights.z;
    }
    
    outAlbedo = accumAlbedo;
    outAO = accumAO;
    outRoughness = accumRoughness;
    outMetallic = accumMetallic;
    outNormal = normal;
}

// -----------------------------------------------------------------------------
// TRAVERSAL
// -----------------------------------------------------------------------------

struct HitInfo 
{
    bool hit;
    float3 pos;
    float3 normal;
    uint matId;
    bool isLOD;
    float3 lodColor;
    uint brickId;
};

HitInfo TraceSVO(ChunkDef chunk, float3 rayOriginNode, float3 rayDir, float maxDist, float tStart)
{
    float tCurrent = tStart;
    float tEnd = maxDist;
    int iter = 0;
    float gridSz = 64.0;
    
    HitInfo result;
    result.hit = false;
    result.pos = 0;
    result.normal = 0;
    result.matId = 0;
    result.isLOD = false;
    result.lodColor = 0;
    result.brickId = 0;

    while (tCurrent < tEnd && iter < _MaxIterations) 
    {
        iter++;
        float3 pos = rayOriginNode + rayDir * (tCurrent + EPSILON);
        uint nodeIndex = 0;
        float nodeSize = gridSz;
        float3 nodePos = float3(0,0,0);
        bool hitLeaf = false;
        
        // Traverse Octree Layers
        for (int depth = 0; depth < 5; depth++) 
        {
            float halfSize = nodeSize * 0.5;
            float3 center = nodePos + halfSize;
            int octant = 0;
            if (pos.x >= center.x) octant |= 1;
            if (pos.y >= center.y) octant |= 2;
            if (pos.z >= center.z) octant |= 4;
            
            SVONode node = _GlobalNodeBuffer[GetPhysicalIndex(nodeIndex, chunk.pageTableOffset, _PageTableBuffer)];
            uint childMask = (node.topology >> 24) & 0xFF;
            
            if ((childMask & (1 << octant)) != 0) 
            {
                uint childBase = node.topology & 0xFFFFFF;
                uint maskBefore = childMask & ((1 << octant) - 1);
                uint childNodeIndex = childBase + countbits(maskBefore);
                
                float3 childPos = nodePos + float3((octant & 1) ? halfSize : 0, (octant & 2) ? halfSize : 0, (octant & 4) ? halfSize : 0);
                float3 childSize = halfSize;
                
                nodeIndex = childNodeIndex;
                nodeSize = childSize;
                nodePos = childPos;
                
                if (nodeSize <= BRICK_SIZE + EPSILON) 
                {
                    hitLeaf = true;
                    break;
                }
            }
            else 
            {
                // Missed child, skip to next octant boundary
                float3 octantMin = nodePos + float3((octant & 1) ? halfSize : 0, (octant & 2) ? halfSize : 0, (octant & 4) ? halfSize : 0);
                float2 tOctant = IntersectBox(rayOriginNode, rayDir, octantMin, octantMin + halfSize);
                tCurrent = tOctant.y;
                break;
            }
        }
        
        if (hitLeaf) 
        {
            SVONode leafNode = _GlobalNodeBuffer[GetPhysicalIndex(nodeIndex, chunk.pageTableOffset, _PageTableBuffer)];
            float2 tLeaf = IntersectBox(rayOriginNode, rayDir, nodePos, nodePos + nodeSize);
            
            // Check for LOD/Solid leaf
            if (leafNode.packedInfo & NODE_FLAG_SOLID) 
            {
                result.hit = true;
                result.pos = rayOriginNode + rayDir * tLeaf.x;
                result.normal = GetLODNormal(result.pos, nodePos, float3(nodeSize, nodeSize, nodeSize));
                result.matId = (leafNode.packedInfo >> 16) & 0xFF;
                result.brickId = 0;
                return result;
            }
            
            // Handle Voxel Payload
            uint payloadIndex, matID;
            UnpackNode(leafNode, payloadIndex, matID);
            
            if (payloadIndex != 0) 
            {
                VoxelPayload payload = _GlobalPayloadBuffer[GetPhysicalIndex(payloadIndex, chunk.payloadPageTableOffset, _PageTableBuffer)];
                uint brickPtr = payload.brickDataIndex;
                float tMarch = max(tCurrent, tLeaf.x);
                float marchEnd = min(tEnd, tLeaf.y);
                
                // Raymarch inside brick
                for (int m = 0; m < _MaxMarchSteps; m++) 
                {
                    if (tMarch >= marchEnd) break;
                    
                    float3 p = rayOriginNode + rayDir * tMarch;
                    float3 localPos = p - nodePos;
                    float dist = SampleBrick(chunk.brickOffset, brickPtr, localPos);
                    
                    if (dist < EPSILON) 
                    {
                        // Binary search refinement for exact surface hit
                        float tMin = tMarch - 0.05;
                        float tMax = tMarch;
                        for(int r = 0; r < 4; r++) 
                        {
                            float tMid = (tMin + tMax) * 0.5;
                            float dMid = SampleBrick(chunk.brickOffset, brickPtr, (rayOriginNode + rayDir * tMid) - nodePos);
                            if (dMid < EPSILON) tMax = tMid; else tMin = tMid;
                        }
                        tMarch = tMax;
                        p = rayOriginNode + rayDir * tMarch;
                        localPos = p - nodePos;
                        
                        result.hit = true;
                        result.pos = p;
                        result.normal = GetVoxelNormal(chunk.brickOffset, brickPtr, localPos);
                        result.matId = GetVoxelMaterial(chunk.brickOffset, brickPtr, localPos);
                        result.brickId = brickPtr;
                        return result;
                    }
                    tMarch += max(dist, 0.001);
                }
            }
            tCurrent = tLeaf.y + EPSILON;
        }
    }
    return result;
}

// -----------------------------------------------------------------------------
// KERNEL
// -----------------------------------------------------------------------------

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    _Result.GetDimensions(width, height);
    if (id.x >= width || id.y >= height) return;

    // 1. Ray Generation
    float2 jitter = _RaytraceParams.yz;
    float2 uv = (id.xy + 0.5 + jitter) / float2(width, height) * 2.0 - 1.0;
    float4 viewRay = mul(_CameraInverseProjection, float4(uv, 0.0, 1.0));
    float3 rayDir = normalize(mul((float3x3)_CameraToWorld, viewRay.xyz));
    float3 rayOrigin = _CameraToWorld._m03_m13_m23;
    
    // Depth Buffer Culling
    float depthVal = _CameraDepthTexture.SampleLevel(sampler_CameraDepthTexture, (id.xy + 0.5) / float2(width, height), 0);
    float linearDepth = 1.0 / (_ZBufferParams.z * depthVal + _ZBufferParams.w);
    float3 forward = normalize(mul((float3x3)_CameraToWorld, float3(0, 0, 1)));
    float maxDist = linearDepth / max(dot(rayDir, forward), 0.0001);
    
    float dither = GetDither(id.xy);
    rayOrigin += rayDir * dither * 0.05;

    float closestT = maxDist;
    HitInfo bestHit = (HitInfo)0;
    bestHit.hit = false;
    bool anyHit = false;

    // 2. TLAS Traversal (Grid DDA)
    float2 tScene = IntersectBox(rayOrigin, rayDir, _TLASBoundsMin, _TLASBoundsMax);
    
    if (tScene.x < tScene.y && tScene.y > 0) 
    {
        float tCurrent = max(0.0, tScene.x);
        float tMaxLimit = min(closestT, tScene.y);
        float3 cellSize = (_TLASBoundsMax - _TLASBoundsMin) / float(_TLASResolution);
        float3 invDir = 1.0 / (rayDir + sign(rayDir) * 1e-6);
        
        float3 startPos = rayOrigin + rayDir * (tCurrent + 1e-4) - _TLASBoundsMin;
        int3 cellIdx = clamp(int3(startPos / cellSize), 0, _TLASResolution - 1);
        int3 step = int3(sign(rayDir));
        float3 tDelta = abs(cellSize * invDir);
        float3 cellBoundMin = _TLASBoundsMin + float3(cellIdx) * cellSize;
        float3 cellBoundMax = cellBoundMin + cellSize;
        float3 nextBoundary = float3(
            rayDir.x > 0 ? cellBoundMax.x : cellBoundMin.x,
            rayDir.y > 0 ? cellBoundMax.y : cellBoundMin.y,
            rayDir.z > 0 ? cellBoundMax.z : cellBoundMin.z
        );
        float3 tNext = (nextBoundary - rayOrigin) * invDir;

        int iter = 0;
        int maxIter = _TLASResolution * 3;
        
        while (iter < maxIter && tCurrent < tMaxLimit) 
        {
             if (all(cellIdx >= 0) && all(cellIdx < _TLASResolution)) 
             {
                 uint flatIdx = cellIdx.z * _TLASResolution * _TLASResolution + cellIdx.y * _TLASResolution + cellIdx.x;
                 TLASCell cell = _TLASGridBuffer[flatIdx];
                 
                 for (uint k = 0; k < cell.count; k++) 
                 {
                     int chunkId = _TLASChunkIndexBuffer[cell.offset + k];
                     ChunkDef chunk = _ChunkBuffer[chunkId];
                     float2 tBox = IntersectBox(rayOrigin, rayDir, chunk.boundsMin, chunk.boundsMax);
                     
                     if (tBox.x < tBox.y && tBox.x < closestT && tBox.y > tCurrent - 0.01) 
                     {
                         if (tBox.y > tCurrent) 
                         {
                             float3 localOrigin = mul(chunk.worldToLocal, float4(rayOrigin, 1.0)).xyz;
                             float3 localDir = normalize(mul((float3x3)chunk.worldToLocal, rayDir));
                             float boundsSz = 64.0;
                             float2 tLocalBox = IntersectBox(localOrigin, localDir, float3(0,0,0), float3(boundsSz, boundsSz, boundsSz));
                             
                             if (tLocalBox.x < tLocalBox.y && tLocalBox.y > 0) 
                             {
                                 float tStartL = max(0.0, tLocalBox.x);
                                 float tEndL = tLocalBox.y;
                                 HitInfo info = TraceSVO(chunk, localOrigin, localDir, tEndL, tStartL);
                                 
                                 if (info.hit) 
                                 {
                                     float3 hitWorld = mul(chunk.localToWorld, float4(info.pos, 1.0)).xyz;
                                     float dist = length(hitWorld - rayOrigin);
                                     if (dist < closestT) 
                                     {
                                         closestT = dist;
                                         bestHit = info;
                                         bestHit.pos = hitWorld;
                                         bestHit.normal = normalize(mul(info.normal, (float3x3)chunk.worldToLocal));
                                         anyHit = true;
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
             
             // Step DDA
             float tExit = min(min(tNext.x, tNext.y), tNext.z);
             if (closestT < tExit) break;
             
             tCurrent = tExit;
             if (tNext.x <= tNext.y && tNext.x <= tNext.z) 
             {
                 tNext.x += tDelta.x;
                 cellIdx.x += step.x;
             } 
             else if (tNext.y <= tNext.z) 
             {
                 tNext.y += tDelta.y;
                 cellIdx.y += step.y;
             } 
             else 
             {
                 tNext.z += tDelta.z;
                 cellIdx.z += step.z;
             }
             iter++;
        }
    }

    // 3. Shading & Output
    if (anyHit)
    {
        float3 albedo, normal;
        float roughness, ao, metallic;
        
        if (bestHit.isLOD) 
        {
            float dist = length(bestHit.pos - rayOrigin);
            float spotSize = dist * _RaytraceParams.x;
            float mip = max(0.0, log2(spotSize * 16.0));
            TriplanarSampling(bestHit.pos, bestHit.normal, bestHit.matId, albedo, normal, roughness, metallic, ao, mip);
        } 
        else 
        {
            TriplanarSampling(bestHit.pos, bestHit.normal, bestHit.matId, albedo, normal, roughness, metallic, ao, 0);
        }
        
        float3 V = normalize(rayOrigin - bestHit.pos); 
        float3 L = normalize(_MainLightPosition.xyz);
        
        float3 color = LightingCel(albedo, bestHit.normal, V, L, _MainLightColor.rgb, roughness, metallic, ao);

        // Debug Views
        if (_DebugViewBricks > 0.5) 
        {
            if (bestHit.isLOD) 
                color = float3(1.0, 0.0, 0.0) * 0.5 + bestHit.lodColor * 0.5;
            else if (bestHit.brickId == 0) 
                color = float3(0, 1, 0);
            else 
                color = GetRandomColor(bestHit.brickId);
        }
        if (_DebugViewNormals > 0.5) 
            color = bestHit.normal * 0.5 + 0.5;
        
        _Result[id.xy] = float4(color, 1.0);
        
        // Output Depth & Motion Vectors
        float4 clipPos = mul(_CameraViewProjection, float4(bestHit.pos, 1.0));
        _ResultDepth[id.xy] = clipPos.z / clipPos.w;
        
        float4 prevClipPos = mul(_PrevViewProjMatrix, float4(bestHit.pos, 1.0));
        float2 ndc = clipPos.xy / clipPos.w;
        float2 prevNdc = prevClipPos.xy / prevClipPos.w;
        float2 currentUV = ndc * 0.5 + 0.5;
        float2 prevUV = prevNdc * 0.5 + 0.5;
        
        _MotionVectorTexture[id.xy] = currentUV - prevUV;
    }
    else
    {
        // Skybox / Miss Shader
        float2 sampleUV = uv * 0.5 + 0.5;
        float4 skyColor = _SourceTex.SampleLevel(sampler_LinearRepeat, sampleUV, 0);
        _Result[id.xy] = float4(skyColor.rgb, 1.0);
        _ResultDepth[id.xy] = 0.0;
        
        // Motion Vectors for sky
        float3 farPos = rayOrigin + rayDir * 1000.0;
        float4 clipPos = mul(_CameraViewProjection, float4(farPos, 1.0));
        float4 prevClipPos = mul(_PrevViewProjMatrix, float4(farPos, 1.0));
        float2 ndc = clipPos.xy / clipPos.w;
        float2 prevNdc = prevClipPos.xy / prevClipPos.w;
        float2 currentUV = ndc * 0.5 + 0.5;
        float2 prevUV = prevNdc * 0.5 + 0.5;
        
        _MotionVectorTexture[id.xy] = currentUV - prevUV;
    }
    
    // Mouse Picking
    if (all(id.xy == (uint2)_MousePosition)) 
    {
        _RaycastBuffer[0] = float4(bestHit.pos, anyHit ? 1.0 : 0.0);
    }
}