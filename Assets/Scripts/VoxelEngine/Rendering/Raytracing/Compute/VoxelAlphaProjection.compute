#pragma kernel CSMain

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "../../../Shared/Shaders/Includes/VoxelStructures.hlsl"

// -----------------------------------------------------------------------------
// BUFFERS & UNIFORMS
// -----------------------------------------------------------------------------

StructuredBuffer<SVONode> _GlobalNodeBuffer;
StructuredBuffer<VoxelPayload> _GlobalPayloadBuffer;
StructuredBuffer<uint> _GlobalBrickDataBuffer;
StructuredBuffer<uint> _PageTableBuffer;
StructuredBuffer<ChunkDef> _ChunkBuffer;
int _ChunkCount;

// TLAS
StructuredBuffer<TLASCell> _TLASGridBuffer;
StructuredBuffer<int> _TLASChunkIndexBuffer;
float3 _TLASBoundsMin;
float3 _TLASBoundsMax;
int _TLASResolution;

// Output
RWTexture2D<float4> _Result;

// Settings
float _CaptureSize; // World size of the capture area
float3 _CaptureCenter; // Center of the capture
int _MaxIterations;
int _MaxMarchSteps;

#define EPSILON 0.01

struct HitInfo 
{
    bool hit;
    float3 pos;
    float3 normal;
    uint matId;
    bool isLOD;
    float3 lodColor;
    uint brickId;
};

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS (Copied/Simplified from VoxelRaytracer)
// -----------------------------------------------------------------------------

float2 IntersectBox(float3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax) 
{
    float3 tMin = (boxMin - rayOrigin) / rayDir;
    float3 tMax = (boxMax - rayOrigin) / rayDir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return float2(tNear, tFar);
}

float3 GetLODNormal(float3 hitPos, float3 boxPos, float3 boxSize) 
{
    float3 center = boxPos + boxSize * 0.5;
    float3 p = hitPos - center;
    float3 signP = sign(p);
    float3 absP = abs(p);
    float bevelSize = boxSize.x * 0.1;
    float3 bevelNormal = normalize(max(absP - (boxSize * 0.5 - bevelSize), 0.0) * signP);
    if (length(bevelNormal) > 0.001) return bevelNormal;
    float maxAxis = max(max(absP.x, absP.y), absP.z);
    if (absP.x >= maxAxis - 1e-4) return float3(signP.x, 0, 0);
    if (absP.y >= maxAxis - 1e-4) return float3(0, signP.y, 0);
    return float3(0, 0, signP.z);
}

float SampleBrick(uint brickOffset, uint brickPtr, float3 localPos) 
{
    float3 p = localPos + (float)BRICK_PADDING;
    int3 i = clamp((int3)floor(p), 0, BRICK_STORAGE_SIZE - 2);
    float3 f = p - (float3)i;
    uint baseIdx = brickOffset + brickPtr + (i.z * BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE) + (i.y * BRICK_STORAGE_SIZE) + i.x;
    uint sliceStride = BRICK_STORAGE_SIZE * BRICK_STORAGE_SIZE;
    
    float s000, s001, s010, s011, s100, s101, s110, s111;
    float3 n;
    uint m;
    // We only care about SDF (s) here
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx], s000, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + 1], s001, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + BRICK_STORAGE_SIZE], s010, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + BRICK_STORAGE_SIZE + 1], s011, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride], s100, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + 1], s101, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + BRICK_STORAGE_SIZE], s110, n, m);
    UnpackVoxelData(_GlobalBrickDataBuffer[baseIdx + sliceStride + BRICK_STORAGE_SIZE + 1], s111, n, m);
    
    float res = lerp(
        lerp(lerp(s000, s001, f.x), lerp(s010, s011, f.x), f.y),
        lerp(lerp(s100, s101, f.x), lerp(s110, s111, f.x), f.y),
        f.z
    );
    return res;
}

HitInfo TraceSVO(ChunkDef chunk, float3 rayOriginNode, float3 rayDir, float maxDist, float tStart)
{
    float tCurrent = tStart;
    float tEnd = maxDist;
    int iter = 0;
    float gridSz = 64.0; // Assuming 64 resolution based on VoxelVolume default
    
    HitInfo result;
    result.hit = false;
    result.pos = 0;
    result.normal = 0;
    result.matId = 0;
    result.isLOD = false;
    result.lodColor = 0;
    result.brickId = 0;

    while (tCurrent < tEnd && iter < _MaxIterations) 
    {
        iter++;
        float3 pos = rayOriginNode + rayDir * (tCurrent + EPSILON);
        uint nodeIndex = 0;
        float nodeSize = gridSz;
        float3 nodePos = float3(0,0,0);
        bool hitLeaf = false;
        
        for (int depth = 0; depth < 5; depth++) 
        {
            float halfSize = nodeSize * 0.5;
            float3 center = nodePos + halfSize;
            int octant = 0;
            if (pos.x >= center.x) octant |= 1;
            if (pos.y >= center.y) octant |= 2;
            if (pos.z >= center.z) octant |= 4;
            
            SVONode node = _GlobalNodeBuffer[GetPhysicalIndex(nodeIndex, chunk.pageTableOffset, _PageTableBuffer)];
            uint childMask = (node.topology >> 24) & 0xFF;
            
            if ((childMask & (1 << octant)) != 0) 
            {
                uint childBase = node.topology & 0xFFFFFF;
                uint maskBefore = childMask & ((1 << octant) - 1);
                nodeIndex = childBase + countbits(maskBefore);
                nodeSize = halfSize;
                nodePos += float3((octant & 1) ? halfSize : 0, (octant & 2) ? halfSize : 0, (octant & 4) ? halfSize : 0);
                
                if (nodeSize <= BRICK_SIZE + EPSILON) 
                {
                    hitLeaf = true;
                    break;
                }
            }
            else 
            {
                float3 octantMin = nodePos + float3((octant & 1) ? halfSize : 0, (octant & 2) ? halfSize : 0, (octant & 4) ? halfSize : 0);
                float2 tOctant = IntersectBox(rayOriginNode, rayDir, octantMin, octantMin + halfSize);
                tCurrent = tOctant.y;
                break;
            }
        }
        
        if (hitLeaf) 
        {
            SVONode leafNode = _GlobalNodeBuffer[GetPhysicalIndex(nodeIndex, chunk.pageTableOffset, _PageTableBuffer)];
            float2 tLeaf = IntersectBox(rayOriginNode, rayDir, nodePos, nodePos + nodeSize);
            
            if (leafNode.packedInfo & NODE_FLAG_SOLID) 
            {
                result.hit = true;
                return result;
            }
            
            uint payloadIndex, matID;
            UnpackNode(leafNode, payloadIndex, matID);
            
            if (payloadIndex != 0) 
            {
                VoxelPayload payload = _GlobalPayloadBuffer[GetPhysicalIndex(payloadIndex, chunk.payloadPageTableOffset, _PageTableBuffer)];
                uint brickPtr = payload.brickDataIndex;
                float tMarch = max(tCurrent, tLeaf.x);
                float marchEnd = min(tEnd, tLeaf.y);
                
                for (int m = 0; m < _MaxMarchSteps; m++) 
                {
                    if (tMarch >= marchEnd) break;
                    float3 p = rayOriginNode + rayDir * tMarch;
                    float3 localPos = p - nodePos;
                    float dist = SampleBrick(chunk.brickOffset, brickPtr, localPos);
                    
                    if (dist < EPSILON) // Hit surface
                    {
                         result.hit = true;
                         return result;
                    }
                    tMarch += max(dist, 0.001);
                }
            }
            tCurrent = tLeaf.y + EPSILON;
        }
    }
    return result;
}

HitInfo TraceScene(float3 rayOrigin, float3 rayDir, float maxDist)
{
    HitInfo bestHit;
    bestHit.hit = false;
    bestHit.pos = float3(0,0,0);
    bestHit.normal = float3(0,0,0);
    bestHit.matId = 0;
    bestHit.isLOD = false;
    bestHit.lodColor = float3(0,0,0);
    bestHit.brickId = 0;

    float2 tScene = IntersectBox(rayOrigin, rayDir, _TLASBoundsMin, _TLASBoundsMax);
    if (tScene.x < tScene.y && tScene.y > 0) 
    {
        float tCurrent = max(0.0, tScene.x);
        float tMaxLimit = min(maxDist, tScene.y);
        
        float3 cellSize = (_TLASBoundsMax - _TLASBoundsMin) / float(_TLASResolution);
        float3 invDir = 1.0 / (rayDir + sign(rayDir) * 1e-6);
        
        float3 startPos = rayOrigin + rayDir * (tCurrent + 1e-4) - _TLASBoundsMin;
        int3 cellIdx = clamp(int3(startPos / cellSize), 0, _TLASResolution - 1);
        int3 step = int3(sign(rayDir));
        float3 tDelta = abs(cellSize * invDir);
        
        float3 cellBoundMin = _TLASBoundsMin + float3(cellIdx) * cellSize;
        float3 cellBoundMax = cellBoundMin + cellSize;
        float3 nextBoundary = float3(
            rayDir.x > 0 ? cellBoundMax.x : cellBoundMin.x,
            rayDir.y > 0 ? cellBoundMax.y : cellBoundMin.y,
            rayDir.z > 0 ? cellBoundMax.z : cellBoundMin.z
        );
        
        float3 tNext = (nextBoundary - rayOrigin) * invDir;
        
        // DDA Loop
        int iter = 0;
        int maxIter = _TLASResolution * 3;
        
        while (iter < maxIter && tCurrent < tMaxLimit)
        {
             if (all(cellIdx >= 0) && all(cellIdx < _TLASResolution)) 
             {
                 uint flatIdx = cellIdx.z * _TLASResolution * _TLASResolution + cellIdx.y * _TLASResolution + cellIdx.x;
                 TLASCell cell = _TLASGridBuffer[flatIdx];
                 
                 for (uint k = 0; k < cell.count; k++) 
                 {
                     int chunkId = _TLASChunkIndexBuffer[cell.offset + k];
                     ChunkDef chunk = _ChunkBuffer[chunkId];
                     float2 tBox = IntersectBox(rayOrigin, rayDir, chunk.boundsMin, chunk.boundsMax);
                     
                     if (tBox.x < tBox.y && tBox.y > tCurrent) 
                     {
                          float3 localOrigin = mul(chunk.worldToLocal, float4(rayOrigin, 1.0)).xyz;
                          float3 localDir = normalize(mul((float3x3)chunk.worldToLocal, rayDir));
                          float boundsSz = 64.0;
                          float2 tLocalBox = IntersectBox(localOrigin, localDir, float3(0,0,0), float3(boundsSz, boundsSz, boundsSz));
                          
                          if (tLocalBox.x < tLocalBox.y && tLocalBox.y > 0) 
                          {
                             float tStartL = max(0.0, tLocalBox.x);
                             float tEndL = tLocalBox.y;
                             HitInfo info = TraceSVO(chunk, localOrigin, localDir, tEndL, tStartL);
                             if (info.hit) 
                             {
                                 bestHit = info;
                                 bestHit.hit = true;
                                 return bestHit; 
                             }
                         }
                     }
                 }
             }
             
             float tExit = min(min(tNext.x, tNext.y), tNext.z);
             tCurrent = tExit;
             
             if (tNext.x <= tNext.y && tNext.x <= tNext.z) 
             {
                 tNext.x += tDelta.x;
                 cellIdx.x += step.x;
             } 
             else if (tNext.y <= tNext.z) 
             {
                 tNext.y += tDelta.y;
                 cellIdx.y += step.y;
             } 
             else 
             {
                 tNext.z += tDelta.z;
                 cellIdx.z += step.z;
             }
             
             iter++;
        }
    }
    return bestHit;
}

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    _Result.GetDimensions(width, height);
    if (id.x >= width || id.y >= height) return;

    // Orthographic Projection from +Z looking down -Z
    // X maps to X, Y maps to Y
    float2 uv = (id.xy + 0.5) / float2(width, height); // 0..1
    float2 localPos = (uv - 0.5) * _CaptureSize;
    
    float3 rayOrigin = _CaptureCenter + float3(localPos.x, localPos.y, _CaptureSize); // Start at Front (+Z)
    float3 rayDir = float3(0, 0, -1); // Look Back (-Z)

    HitInfo hit = TraceScene(rayOrigin, rayDir, _CaptureSize * 2.0);
    
    float alpha = hit.hit ? 1.0 : 0.0;
    _Result[id.xy] = float4(alpha, alpha, alpha, alpha);
}
